// vulnerability-drivers.js

// Initialize the vulnerability drivers visualization
function initVulnerabilityDrivers(containerId) {
  // Constants
  const margin = { top: 50, right: 140, bottom: 80, left: 80 };
  const width = 900 - margin.left - margin.right;
  const height = 500 - margin.top - margin.bottom;
  
  // Clear any existing content in the container first
  d3.select('#' + containerId).html('');
  
  // Create the SVG container
  const svg = d3.select('#' + containerId)
    .append('svg')
    .attr('width', width + margin.left + margin.right)
    .attr('height', height + margin.top + margin.bottom)
    .append('g')
    .attr('transform', `translate(${margin.left}, ${margin.top})`);
  
  // Add title
  svg.append('text')
    .attr('class', 'chart-title')
    .attr('x', width / 2)
    .attr('y', -20)
    .attr('text-anchor', 'middle')
    .style('font-size', '20px')
    .style('font-weight', 'bold')
    .text('Vulnerability Profile by Region');
  
  // Create a tooltip
  const tooltip = d3.select('body')
    .append('div')
    .attr('class', 'viz-tooltip')
    .style('opacity', 0)
    .style('position', 'absolute')
    .style('background-color', 'white')
    .style('border', '1px solid #ddd')
    .style('border-radius', '4px')
    .style('padding', '10px')
    .style('box-shadow', '0 2px 5px rgba(0,0,0,0.1)')
    .style('pointer-events', 'none')
    .style('font-size', '12px')
    .style('max-width', '250px')
    .style('z-index', '1000');
  
  // Create controls container
  const controls = d3.select('#' + containerId)
    .append('div')
    .attr('class', 'chart-controls')
    .style('margin', '20px 0')
    .style('display', 'flex')
    .style('flex-direction', 'column')
    .style('gap', '15px');
  
  // Region filter
  const regionFilter = controls.append('div');
  
  const regionHeader = regionFilter.append('div')
    .style('display', 'flex')
    .style('align-items', 'center')
    .style('margin-bottom', '10px');
  
  regionHeader.append('span')
    .text('Regions: ')
    .style('font-weight', 'bold')
    .style('min-width', '100px');
  
  const regions = [
    'Caribbean Region',
    'Andean Region', 
    'Amazon Region', 
    'Pacific Region', 
    'Orinoco Region'
  ];
  
  const regionColors = d3.scaleOrdinal()
    .domain(regions)
    .range(d3.schemeCategory10);
  
  const regionCheckboxes = regionFilter.append('div')
    .style('display', 'flex')
    .style('flex-wrap', 'wrap')
    .style('gap', '10px');
  
  regions.forEach(region => {
    const label = regionCheckboxes.append('label')
      .style('display', 'flex')
      .style('align-items', 'center')
      .style('gap', '5px')
      .style('cursor', 'pointer')
      .style('padding', '5px')
      .style('border-radius', '4px')
      .style('border', `1px solid ${regionColors(region)}`)
      .style('margin-right', '10px');
    
    label.append('input')
      .attr('type', 'checkbox')
      .attr('name', 'region')
      .attr('value', region)
      .attr('checked', true);
    
    label.append('span')
      .text(region)
      .style('color', regionColors(region));
  });
  
// Create a container for both the info panel and map legend to sit side by side
const infoContainer = d3.select('#' + containerId)
  .append('div')
  .attr('class', 'info-container')
  .style('display', 'flex')
  .style('flex-wrap', 'wrap')
  .style('gap', '20px')
  .style('margin-top', '20px');

// Create information panel in the container
const infoPanel = infoContainer.append('div')
  .attr('class', 'info-panel')
  .style('flex', '1')
  .style('min-width', '250px')
  .style('background-color', '#f0f9ff')
  .style('border-left', '4px solid #3b82f6')
  .style('padding', '15px')
  .style('border-radius', '4px');

// Add the content to the info panel
infoPanel.append('h3')
  .text('Key Insights:')
  .style('margin-top', '0')
  .style('margin-bottom', '10px')
  .style('font-weight', 'bold')
  .style('color', '#1e40af');

const insightsList = infoPanel.append('ul')
  .style('margin', '10px 0')
  .style('padding-left', '25px')
  .style('color', '#1e3a8a');

insightsList.append('li')
  .text('Healthcare access is the most significant challenge in the Amazon and Pacific regions.');

insightsList.append('li')
  .text('The Andean region has the lowest overall vulnerability, likely due to higher urbanization.');

insightsList.append('li')
  .text('Demographic factors drive vulnerability in coastal and indigenous-populated regions.');

insightsList.append('li')
  .text('Basic services access varies dramatically between urban centers and rural municipalities.');

// Store references to these elements for later updates
return {
  svg,
  tooltip,
  width,
  height,
  regionColors,
  margin,
  containerId
};

}

// Process real vulnerability data from the main application
function processRealVulnerabilityData(year) {
  // Define Colombia's actual regions
  const regions = [
    'Caribbean Region',
    'Andean Region', 
    'Amazon Region', 
    'Pacific Region', 
    'Orinoco Region'
  ];
  
  const regionData = {};
  
  // Initialize region data
  regions.forEach(region => {
    regionData[region] = {
      name: region,
      municipalities: [],
      basicServices: 0,
      healthcare: 0,
      socioeconomic: 0,
      demographic: 0,
      overall: 0,
      count: 0
    };
  });
  
  // Mapping from first 2 digits of code to region
  const codeToRegion = {
    '05': 'Andean Region', // Antioquia
    '08': 'Caribbean Region', // Atlántico
    '11': 'Andean Region', // Bogotá
    '13': 'Caribbean Region', // Bolívar
    '15': 'Andean Region', // Boyacá
    '17': 'Andean Region', // Caldas
    '18': 'Amazon Region', // Caquetá
    '19': 'Pacific Region', // Cauca
    '20': 'Caribbean Region', // Cesar
    '23': 'Caribbean Region', // Córdoba
    '25': 'Andean Region', // Cundinamarca
    '27': 'Pacific Region', // Chocó
    '41': 'Andean Region', // Huila
    '44': 'Caribbean Region', // La Guajira
    '47': 'Caribbean Region', // Magdalena
    '50': 'Orinoco Region', // Meta
    '52': 'Pacific Region', // Nariño
    '54': 'Andean Region', // Norte de Santander
    '63': 'Andean Region', // Quindío
    '66': 'Andean Region', // Risaralda
    '68': 'Andean Region', // Santander
    '70': 'Caribbean Region', // Sucre
    '73': 'Andean Region', // Tolima
    '76': 'Pacific Region', // Valle del Cauca
    '81': 'Orinoco Region', // Arauca
    '85': 'Orinoco Region', // Casanare
    '86': 'Amazon Region', // Putumayo
    '88': 'Amazon Region', // San Andrés
    '91': 'Amazon Region', // Amazonas
    '94': 'Amazon Region', // Guainía
    '95': 'Amazon Region', // Guaviare
    '97': 'Amazon Region', // Vaupés
    '99': 'Orinoco Region'  // Vichada
  };
  
  // Process each municipality
  Object.keys(window.municipalitiesData).forEach(code => {
    const municipalityYearData = window.municipalitiesData[code][year];
    if (!municipalityYearData) return;
    
    // Determine region based on municipality code
    let region = 'Andean Region'; // Default
    
    // Try to determine region from municipality code
    const deptCode = code.toString().substring(0, 2);
    if (codeToRegion[deptCode]) {
      region = codeToRegion[deptCode];
    } 
    // If code-based lookup fails, try name-based matching
    else if (municipalityYearData.name) {
      const name = municipalityYearData.name.toLowerCase();
      
      // Check for Caribbean region indicators
      if (name.includes('caribe') || 
          name.includes('barranquilla') || 
          name.includes('cartagena') || 
          name.includes('santa marta')) {
        region = 'Caribbean Region';
      } 
      // Check for Pacific region indicators
      else if (name.includes('pacífico') || 
               name.includes('chocó') || 
               name.includes('buenaventura')) {
        region = 'Pacific Region';
      } 
      // Check for Amazon region indicators
      else if (name.includes('amazonas') || 
               name.includes('leticia') || 
               name.includes('putumayo') || 
               name.includes('caquetá')) {
        region = 'Amazon Region';
      } 
      // Check for Orinoco region indicators
      else if (name.includes('orinoco') || 
               name.includes('llanos') || 
               name.includes('meta') || 
               name.includes('casanare')) {
        region = 'Orinoco Region';
      }
    }
    
    // Add to region data
    regionData[region].municipalities.push({
      code,
      ...municipalityYearData
    });
    regionData[region].count++;
  });
  
  // Calculate metrics for each region
  regions.forEach(region => {
    const municipalities = regionData[region].municipalities;
    if (municipalities.length === 0) return;
    
    // Use actual vulnerability indicators
    let totalWaterAccess = 0;
    let totalHealthcare = 0; 
    let totalSocioeconomicScore = 0;
    let totalDemographicVulnerability = 0;
    
    // Process each municipality's data to calculate region stats
    municipalities.forEach(muni => {
      // Basic Services component - water access is the primary indicator
      totalWaterAccess += muni.waterAccess || 0;
      
      // Healthcare component - hospitals per km2 (inversely related to vulnerability)
      // Convert to vulnerability score (0-100, higher means more vulnerable)
      const healthcareVulnerability = 100 - Math.min(100, (muni.hospitalsPerKm2 || 0) * 1000);
      totalHealthcare += healthcareVulnerability;
      
      // Socioeconomic component - based on education and employment
      // Convert to vulnerability score (higher means more vulnerable)
      const socioeconomicVulnerability = 100 - (
        ((muni.education || 0) + (muni.employment || 0)) / 2
      );
      totalSocioeconomicScore += socioeconomicVulnerability;
      
      // Demographic component - based on vulnerable populations
      const demographicVulnerability = 
        (muni.age0to4Pct || 0) * 0.5 + 
        (muni.disabilities || 0) * 0.3 + 
        ((muni.indigenousPct || 0) + (muni.afrocolombianPct || 0)) * 0.2;
      totalDemographicVulnerability += demographicVulnerability;
    });
    
    // Calculate regional averages
    const count = municipalities.length;
    regionData[region].basicServices = totalWaterAccess / count;
    regionData[region].healthcare = totalHealthcare / count;
    regionData[region].socioeconomic = totalSocioeconomicScore / count;
    regionData[region].demographic = totalDemographicVulnerability / count;
    
    // Calculate overall vulnerability (weighted average)
    regionData[region].overall = (
      regionData[region].basicServices * 0.35 + 
      regionData[region].healthcare * 0.2 + 
      regionData[region].socioeconomic * 0.3 + 
      regionData[region].demographic * 0.15
    );
    
    // Add contextual descriptions based on the data
    if (regionData[region].overall > 60) {
      regionData[region].description = "Extremely high vulnerability with critical challenges across all factors.";
    } else if (regionData[region].overall > 45) {
      regionData[region].description = "High vulnerability with significant challenges in multiple areas.";
    } else if (regionData[region].overall > 30) {
      regionData[region].description = "Moderate vulnerability with challenges in specific areas.";
    } else {
      regionData[region].description = "Lower overall vulnerability compared to other regions.";
    }
    
    // Add specific insights based on which factors contribute most
    const factors = [
      {name: 'Basic Services', value: regionData[region].basicServices, weight: 0.35},
      {name: 'Healthcare', value: regionData[region].healthcare, weight: 0.2},
      {name: 'Socioeconomic', value: regionData[region].socioeconomic, weight: 0.3},
      {name: 'Demographic', value: regionData[region].demographic, weight: 0.15}
    ];
    
    // Sort to find highest contributor
    factors.sort((a, b) => (b.value * b.weight) - (a.value * a.weight));
    regionData[region].description += ` ${factors[0].name} is the primary driver of vulnerability in this region.`;
  });
  
  // Convert the object to an array for D3
  return regions
    .map(region => regionData[region])
    .filter(region => region.municipalities.length > 0); // Only include regions with data
}

// Generate example data for Colombian regions if real data is not available
function generateVulnerabilityData(year) {
  // First try to use real data
  if (window.municipalitiesData && Object.keys(window.municipalitiesData).length > 0) {
    try {
      const realData = processRealVulnerabilityData(year);
      if (realData && realData.length > 0) {
        console.log(`Using real data for year ${year} with ${realData.length} regions`);
        return realData;
      }
    } catch (error) {
      console.error("Error processing real data:", error);
    }
  }
  
  console.log("Falling back to synthetic data");
  
  // Fallback to synthetic data with real region names
  const regions = [
    { 
      name: "Caribbean Region", 
      basicServices: 45 - (2019 - year) * 1.2, 
      healthcare: 62 - (2019 - year) * 0.9, 
      socioeconomic: 38 - (2019 - year) * 0.7, 
      demographic: 56 - (2019 - year) * 0.3,
      description: "High vulnerability in healthcare access and demographic factors."
    },
    { 
      name: "Andean Region", 
      basicServices: 25 - (2019 - year) * 0.8, 
      healthcare: 30 - (2019 - year) * 0.6, 
      socioeconomic: 22 - (2019 - year) * 0.5, 
      demographic: 18 - (2019 - year) * 0.2,
      description: "Lower overall vulnerability with balanced factor distribution."
    },
    { 
      name: "Amazon Region", 
      basicServices: 68 - (2019 - year) * 0.5, 
      healthcare: 72 - (2019 - year) * 0.4, 
      socioeconomic: 54 - (2019 - year) * 0.5, 
      demographic: 42 - (2019 - year) * 0.3,
      description: "Very high vulnerability in basic services and healthcare."
    },
    { 
      name: "Pacific Region", 
      basicServices: 59 - (2019 - year) * 0.7, 
      healthcare: 65 - (2019 - year) * 0.4, 
      socioeconomic: 51 - (2019 - year) * 0.6, 
      demographic: 63 - (2019 - year) * 0.2,
      description: "High vulnerability across all factors, especially demographic."
    },
    { 
      name: "Orinoco Region", 
      basicServices: 42 - (2019 - year) * 0.9, 
      healthcare: 58 - (2019 - year) * 0.5, 
      socioeconomic: 35 - (2019 - year) * 0.6, 
      demographic: 32 - (2019 - year) * 0.3,
      description: "Moderate vulnerability with healthcare challenges."
    }
  ];
  
  // Ensure all values are positive and within reasonable bounds
  regions.forEach(region => {
    region.basicServices = Math.max(5, Math.min(95, region.basicServices));
    region.healthcare = Math.max(5, Math.min(95, region.healthcare));
    region.socioeconomic = Math.max(5, Math.min(95, region.socioeconomic));
    region.demographic = Math.max(5, Math.min(95, region.demographic));
    
    // Calculate overall vulnerability
    region.overall = (
      region.basicServices * 0.35 + 
      region.healthcare * 0.2 + 
      region.socioeconomic * 0.3 + 
      region.demographic * 0.15
    );
  });
  
  return regions;
}

// Simplified radar chart function - NO ANIMATIONS to ensure immediate rendering
function drawRadarChart(chartElements, data, selectedRegions) {
  console.log(`Drawing radar chart with year: ${window.currentYear}, selected regions:`, selectedRegions);
  
  const { svg, tooltip, width, height, regionColors } = chartElements;
  
  // Clear everything
  svg.selectAll('*').remove();
  
  // Filter data by selected regions
  const filteredData = data.filter(d => selectedRegions.includes(d.name));
  
  if (filteredData.length === 0) {
    // Display a message if no regions are selected
    svg.append('text')
      .attr('x', width / 2)
      .attr('y', height / 2)
      .attr('text-anchor', 'middle')
      .style('font-size', '16px')
      .text('Please select at least one region to display data');
    return;
  }

  console.log("Filtered data for chart:", filteredData);
  
  // Set up radar chart parameters
  const centerX = width / 2;
  const centerY = height / 2;
  const radius = Math.min(centerX, centerY) * 0.7;
  
  // Define the radar chart features
  const features = [
    { name: 'Basic Services', key: 'basicServices' },
    { name: 'Healthcare', key: 'healthcare' },
    { name: 'Socioeconomic', key: 'socioeconomic' },
    { name: 'Demographic', key: 'demographic' }
  ];
  
  // Calculate angles for each feature
  const angleSlice = (Math.PI * 2) / features.length;
  
  // Create scale for radar
  const radarScale = d3.scaleLinear()
    .domain([0, 100])
    .range([0, radius]);
  
  // Add chart title with current year
  svg.append('text')
    .attr('class', 'chart-title')
    .attr('x', width / 2)
    .attr('y', -20)
    .attr('text-anchor', 'middle')
    .style('font-size', '18px')
    .style('font-weight', 'bold')
    .text(`Regional Vulnerability Profiles (${window.currentYear || 2019})`);
  
  // Draw grid circles
  const gridGroup = svg.append('g')
    .attr('transform', `translate(${centerX},${centerY})`);
  
  const gridLevels = 4;
  for (let j = 0; j < gridLevels; j++) {
    const levelFactor = radius * ((j + 1) / gridLevels);
    
    // Draw circle
    gridGroup.append('circle')
      .attr('r', levelFactor)
      .style('fill', 'none')
      .style('stroke', 'gray')
      .style('stroke-opacity', 0.2);
    
    // Add value label
    gridGroup.append('text')
      .attr('x', 5)
      .attr('y', -levelFactor + 5)
      .attr('dy', '0.35em')
      .style('font-size', '10px')
      .style('fill', 'gray')
      .style('opacity', 0.6)
      .text(`${Math.round(100 * (j + 1) / gridLevels)}`);
  }
  
  // Draw axis lines and labels
  const axisGroup = svg.append('g')
    .attr('transform', `translate(${centerX},${centerY})`);
  
  features.forEach((feature, i) => {
    // Calculate angle (starting from the top and going clockwise)
    const angle = i * angleSlice - Math.PI / 2;
    const x = radius * Math.cos(angle);
    const y = radius * Math.sin(angle);
    
    // Draw axis line
    axisGroup.append('line')
      .attr('x1', 0)
      .attr('y1', 0)
      .attr('x2', x)
      .attr('y2', y)
      .style('stroke', 'gray')
      .style('stroke-opacity', 0.3);
    
    // Place labels with optimal positioning
    let labelX = 1.15 * radius * Math.cos(angle);
    let labelY = 1.15 * radius * Math.sin(angle);
    let textAnchor;
    
    // Adjust label position based on angle
    if (Math.abs(labelX) < 10) {
      textAnchor = 'middle';
    } else if (labelX > 0) {
      textAnchor = 'start';
      labelX += 5; // Add a little spacing
    } else {
      textAnchor = 'end';
      labelX -= 5; // Add a little spacing
    }
    
    // Add label
    axisGroup.append('text')
      .attr('x', labelX)
      .attr('y', labelY)
      .attr('text-anchor', textAnchor)
      .style('font-size', '12px')
      .style('font-weight', 'bold')
      .text(feature.name);
  });
  
  // Create a radial line generator for radar paths
  const radarLine = d3.lineRadial()
    .radius(d => {
      // Ensure we have a valid number
      return radarScale(isNaN(d.value) ? 0 : d.value);
    })
    .angle((d, i) => i * angleSlice - Math.PI / 2)
    .curve(d3.curveLinearClosed);
    
  // Draw radar areas for each region - use reverse to ensure proper overlay
  [...filteredData].reverse().forEach(region => {
    console.log(`Drawing region ${region.name} with data:`, {
      basicServices: region.basicServices,
      healthcare: region.healthcare,
      socioeconomic: region.socioeconomic,
      demographic: region.demographic
    });
    
    // Format data for the radar chart
    const radarData = features.map(feature => ({
      value: region[feature.key] || 0,
      feature: feature.name
    }));
    
    // Create radar group
    const regionGroup = axisGroup.append('g')
      .attr('class', `radar-area region-${region.name.replace(/\s+/g, '-').toLowerCase()}`);
      
    // Draw radar path
    regionGroup.append('path')
      .datum(radarData)
      .attr('d', radarLine)
      .style('fill', regionColors(region.name))
      .style('fill-opacity', 0.3)
      .style('stroke', regionColors(region.name))
      .style('stroke-width', 2.5)
      .on('mouseover', function(event) {
        // Highlight on hover
        d3.select(this)
          .style('fill-opacity', 0.7)
          .style('stroke-width', 4);
        
        // Show tooltip
        tooltip.transition()
          .duration(200)
          .style('opacity', 0.9);
        
        tooltip.html(`
          <strong>${region.name}</strong><br/>
          <table style="width:100%; border-collapse: collapse;">
            <tr><td style="padding:2px 5px;">Basic Services:</td><td>${region.basicServices.toFixed(1)}%</td></tr>
            <tr><td style="padding:2px 5px;">Healthcare:</td><td>${region.healthcare.toFixed(1)}%</td></tr>
            <tr><td style="padding:2px 5px;">Socioeconomic:</td><td>${region.socioeconomic.toFixed(1)}%</td></tr>
            <tr><td style="padding:2px 5px;">Demographic:</td><td>${region.demographic.toFixed(1)}%</td></tr>
            <tr style="font-weight:bold"><td style="padding:2px 5px;">Overall:</td><td>${region.overall.toFixed(1)}%</td></tr>
          </table>
          <small>${region.description || ''}</small>
        `)
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 28) + 'px');
      })
      .on('mouseout', function() {
        // Reset on mouseout
        d3.select(this)
          .style('fill-opacity', 0.3)
          .style('stroke-width', 2.5);
        
        tooltip.transition()
          .duration(500)
          .style('opacity', 0);
      });
  });
  
  
  // Add legend panel with color keys and region map
  const legendSize = 160;
  const legendPanel = svg.append('g')
    .attr('class', 'legend-panel')
    .attr('transform', `translate(${width - legendSize + 30}, 10)`);
  
  // Background panel for legend
  legendPanel.append('rect')
    .attr('width', legendSize)
    .attr('height', Math.max(140, filteredData.length * 20 + 60))
    .attr('fill', '#f8f9fa')
    .attr('stroke', '#dee2e6')
    .attr('stroke-width', 1)
    .attr('rx', 5)
    .attr('ry', 5)
    .attr('opacity', 0.85);
  
  // Add color legend title
  legendPanel.append('text')
    .attr('x', legendSize / 2)
    .attr('y', 20)
    .attr('text-anchor', 'middle')
    .style('font-size', '12px')
    .style('font-weight', 'bold')
    .text('Regions');
  
  // Add color legend entries
  filteredData.forEach((region, i) => {
    const legendRow = legendPanel.append('g')
      .attr('transform', `translate(10, ${i * 20 + 40})`);
    
    legendRow.append('rect')
      .attr('width', 12)
      .attr('height', 12)
      .attr('fill', regionColors(region.name))
      .attr('opacity', 0.7);
    
    legendRow.append('text')
      .attr('x', 20)
      .attr('y', 10)
      .text(region.name)
      .style('font-size', '10px')
      .style('font-weight', '500');
  });
  
  // Mini map of Colombia regions below the color legend
  const mapStart = Math.max(140, filteredData.length * 20 + 70);
  const mapSize = 120;
  
  // Add mini map to the same panel
  const miniMap = legendPanel.append('g')
    .attr('transform', `translate(${legendSize/2 - mapSize/2}, ${mapStart})`);
  
  // Map title
  legendPanel.append('text')
    .attr('x', legendSize / 2)
    .attr('y', mapStart - 10)
    .attr('text-anchor', 'middle')
    .style('font-size', '12px')
    .style('font-weight', 'bold')
  
  // Simplified paths for Colombia's regions
  const regionPaths = [
    {
      name: 'Caribbean Region',
      path: 'M45,25 L65,15 L85,20 L90,30 L75,35 L65,40 L50,45 L40,40 L35,30 Z',
      centroid: [60, 30]
    },
    {
      name: 'Andean Region',
      path: 'M45,45 L60,40 L70,45 L75,60 L70,75 L60,80 L50,75 L45,60 Z',
      centroid: [60, 60]
    },
    {
      name: 'Pacific Region',
      path: 'M35,45 L45,45 L45,60 L50,75 L40,85 L30,75 L25,60 Z',
      centroid: [35, 65]
    },
    {
      name: 'Amazon Region',
      path: 'M70,75 L80,70 L90,75 L95,90 L85,100 L70,95 L65,85 Z',
      centroid: [80, 85]
    },
    {
      name: 'Orinoco Region',
      path: 'M70,45 L80,40 L90,45 L95,60 L90,75 L80,70 L75,60 Z',
      centroid: [82.5, 57.5]
    }
  ];
  
  // Create map background
  miniMap.append('rect')
    .attr('width', mapSize)
    .attr('height', mapSize)
    .attr('fill', '#f1f5f9')
    .attr('rx', 4)
    .attr('ry', 4);
  
  // Draw all region paths - only show those selected
  regionPaths.forEach(region => {
    // Check if this region is in the filtered data (selected)
    const isSelected = filteredData.some(d => d.name === region.name);
    
    miniMap.append('path')
      .attr('d', region.path)
      .attr('fill', regionColors(region.name))
      .attr('stroke', '#fff')
      .attr('stroke-width', 1)
      .attr('fill-opacity', isSelected ? 0.7 : 0.15)
      .attr('class', `mini-map-${region.name.replace(/\s+/g, '-').toLowerCase()}`)
      .style('cursor', 'pointer')
      .on('mouseover', function() {
        if (!isSelected) return;
        
        // Highlight map region
        d3.select(this).attr('fill-opacity', 1);
        
        // Highlight matching region in radar
        const radarRegion = d3.select(`.region-${region.name.replace(/\s+/g, '-').toLowerCase()}`);
        if (!radarRegion.empty()) {
          radarRegion.select('path')
            .style('fill-opacity', 0.7)
            .style('stroke-width', 4);
        }
      })
      .on('mouseout', function() {
        if (!isSelected) return;
        
        // Reset highlighting
        d3.select(this).attr('fill-opacity', 0.7);
        
        // Reset radar region
        const radarRegion = d3.select(`.region-${region.name.replace(/\s+/g, '-').toLowerCase()}`);
        if (!radarRegion.empty()) {
          radarRegion.select('path')
            .style('fill-opacity', 0.3)
            .style('stroke-width', 2.5);
        }
      });
    
    // Only add labels for selected regions
    if (isSelected) {
      miniMap.append('text')
        .attr('x', region.centroid[0])
        .attr('y', region.centroid[1])
        .attr('text-anchor', 'middle')
        .attr('font-size', '7px')
        .attr('fill', '#333')
        .attr('pointer-events', 'none')
        .text(region.name.replace(' Region', ''));
    }
  });
  
  // Add note about region boundaries
  legendPanel.append('text')
    .attr('x', legendSize / 2)
    .attr('y', mapStart + mapSize + 15)
    .attr('text-anchor', 'middle')
    .attr('font-size', '7px')
    .attr('fill', '#666')
    .attr('font-style', 'italic')
    .text('Region boundaries are approximate');
}

// Update the visualization based on current selections
function updateVulnerabilityChart(chartElements, containerId) {
  // Get the current year from the global state
  const currentYear = window.currentYear || 2019;
  console.log("Updating vulnerability chart for year:", currentYear);
  
  // Generate data for the current year
  const data = generateVulnerabilityData(currentYear);
  
  // Get selected regions
  const selectedRegions = [];
  const checkboxes = document.querySelectorAll(`#${containerId} input[name="region"]:checked`);
  checkboxes.forEach(checkbox => {
    selectedRegions.push(checkbox.value);
  });
  
  console.log("Selected regions:", selectedRegions);
  
  // Draw the radar chart
  drawRadarChart(chartElements, data, selectedRegions);
}

// Initialize and create the visualization
function createVulnerabilityDriversVisualization(containerId) {
  console.log("Initializing vulnerability drivers visualization");
  
  // Check if D3 is available
  if (typeof d3 === 'undefined') {
    console.error('D3.js is required for the vulnerability drivers visualization.');
    
    // Create an error message in the container
    const container = document.getElementById(containerId);
    if (container) {
      container.innerHTML = `
        <div style="padding: 20px; background-color: #fff3f3; border-left: 4px solid #f87171; border-radius: 4px;">
          <h3 style="margin-top: 0; color: #b91c1c;">Error: D3.js is required</h3>
          <p>Please include D3.js library to enable this visualization. Add the following script tag to your HTML:</p>
          <pre style="background-color: #f1f5f9; padding: 10px; border-radius: 4px;">
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.0/d3.min.js"&gt;&lt;/script&gt;</pre>
        </div>
      `;
    }
    return null;
  }
  
  // Initialize the chart elements
  const chartElements = initVulnerabilityDrivers(containerId);
  
  // Add event listeners for region changes
  document.querySelectorAll(`#${containerId} input[name="region"]`).forEach(checkbox => {
    checkbox.addEventListener('change', function() {
      updateVulnerabilityChart(chartElements, containerId);
    });
  });
  
  // Force an initial draw
  console.log("Performing initial chart rendering");
  updateVulnerabilityChart(chartElements, containerId);
  
  // Set up listener for year changes from the main application
  window.addEventListener('yearChanged', function(event) {
    console.log("Year changed event received:", event.detail);
    updateVulnerabilityChart(chartElements, containerId);
  });
  
  // Also check for changes in global currentYear variable every second
  // This is a backup in case the event isn't being dispatched correctly
  const yearCheckInterval = setInterval(() => {
    const sliderYear = document.getElementById('yearSlider')?.value;
    if (sliderYear && window.currentYear !== parseInt(sliderYear)) {
      window.currentYear = parseInt(sliderYear);
      console.log("Year change detected through interval check:", window.currentYear);
      updateVulnerabilityChart(chartElements, containerId);
    }
  }, 1000);
  
  // Store the interval for cleanup if needed
  window.vulnerabilityChartYearChecker = yearCheckInterval;
  
  return chartElements;
}